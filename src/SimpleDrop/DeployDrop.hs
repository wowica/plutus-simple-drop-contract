{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeApplications  #-}

module SimpleDrop.DeployDrop
  ( writeJSON
  , writeValidator
  , writeUnit
  , writeDropValidator
  ) where

import           Cardano.Api
import           Cardano.Api.Shelley            ( PlutusScript(..) )
import           Codec.Serialise                ( serialise )
import           Data.Aeson                     ( encode )
import qualified Data.ByteString.Lazy          as LBS
import qualified Data.ByteString.Short         as SBS
import           Data.String                    ( IsString(fromString) )
import qualified Ledger
import           Ledger                         ( PubKeyHash(..) )
import           Ledger.Bytes                   ( LedgerBytes(LedgerBytes)
                                                , fromHex
                                                )
import qualified Plutus.V1.Ledger.Api          as Ledger
import           PlutusTx                       ( Data(..) )
import qualified PlutusTx

import           SimpleDrop.DropValidator

dataToScriptData :: Data -> ScriptData
dataToScriptData (Constr n xs) =
  ScriptDataConstructor n $ dataToScriptData <$> xs
dataToScriptData (Map xs) =
  ScriptDataMap [ (dataToScriptData x, dataToScriptData y) | (x, y) <- xs ]
dataToScriptData (List xs) = ScriptDataList $ dataToScriptData <$> xs
dataToScriptData (I    n ) = ScriptDataNumber n
dataToScriptData (B    bs) = ScriptDataBytes bs

writeJSON :: PlutusTx.ToData a => FilePath -> a -> IO ()
writeJSON file =
  LBS.writeFile file
    . encode
    . scriptDataToJson ScriptDataJsonDetailedSchema
    . dataToScriptData
    . PlutusTx.toData

writeValidator :: FilePath -> Ledger.Validator -> IO (Either (FileError ()) ())
writeValidator file =
  writeFileTextEnvelope @(PlutusScript PlutusScriptV1) file Nothing
    . PlutusScriptSerialised
    . SBS.toShort
    . LBS.toStrict
    . serialise
    . Ledger.unValidatorScript

writeUnit :: IO ()
writeUnit = writeJSON "unit.json" ()

loadPKH :: String -> Maybe Ledger.PaymentPubKeyHash
loadPKH s = Just (Ledger.PaymentPubKeyHash $ pkhFromStr s)

pkhFromStr :: String -> PubKeyHash
pkhFromStr s = case fromHex (fromString s) of
  Right (LedgerBytes bytes) -> PubKeyHash bytes
  Left  _                   -> PubKeyHash ""

loadPkhFromFile :: String -> IO [Ledger.PaymentPubKeyHash]
loadPkhFromFile fname = do
  s <- readFile fname
  case traverse loadPKH (lines s) of
    Nothing        -> error "some line failed to parse"
    Just listOfPkh -> pure listOfPkh

-- Reads pub key hashes from text file
-- generated by reading Blockfrost API.
-- See scripts/delegation_snapshot.sh
aPkh :: IO [Ledger.PaymentPubKeyHash]
aPkh = loadPkhFromFile "scripts/snapshot.txt"

writeDropValidator :: IO (Either (FileError ()) ())
writeDropValidator = do
  apkh <- aPkh
  writeValidator "simple_drop.plutus" $ validator $ DropParam
    { delegators = apkh
    }
